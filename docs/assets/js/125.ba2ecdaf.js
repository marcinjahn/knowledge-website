(window.webpackJsonp=window.webpackJsonp||[]).push([[125],{580:function(e,t,a){"use strict";a.r(t);var i=a(31),s=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"cryptography-basics"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cryptography-basics"}},[e._v("#")]),e._v(" Cryptography Basics")]),e._v(" "),a("h2",{attrs:{id:"attacks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#attacks"}},[e._v("#")]),e._v(" Attacks")]),e._v(" "),a("p",[e._v("There are two ways to break cryptography system:")]),e._v(" "),a("ul",[a("li",[e._v("brute force - protection against it is to have so many password possibilities\nthat it'd be infeasible to try to break it. Another way is to limit the amount\nof attacks that may be performed in a period of time")]),e._v(" "),a("li",[e._v("finding the algorithm weakness")])]),e._v(" "),a("p",[e._v("An algorithm is well designed if its security does not depend on keeping the\nalgorithm itself secret.")]),e._v(" "),a("h2",{attrs:{id:"hash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash"}},[e._v("#")]),e._v(" Hash")]),e._v(" "),a("p",[e._v("Examples: MD5 (broken), SHA-1 (broken), SHA-2, SHA-3")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("SHA-2 and SHA-3 variants")]),e._v(" "),a("p",[e._v('SHA-2/3 comes in different flavours: 224bit, 256bit, 384bit, 512bit.\nSHA-2 omits "2" (e.g. SHA-256).\nSHA-3 includes "3" (e.g. SHA-3-256)')])]),e._v(" "),a("p",[e._v("Hash function turns some data into an irreversible "),a("strong",[e._v("digest")]),e._v(". It's used mostly\nto check if data is correct - if it matches a known hash/digest (data integrity).")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("Infinite inputs")]),e._v(" "),a("p",[e._v("In reality, the second and third properties of hash functions are not possible\nto hold. There are infinite possible inputs to hash functions and a finite\namount of digests (hash result length is fixed).")])]),e._v(" "),a("p",[e._v("SHA-256 is a good enough choice, but SHA-3 is recommended.")]),e._v(" "),a("p",[e._v("Hash functions have the following properties:")]),e._v(" "),a("ul",[a("li",[e._v("pre-image resistance - we can't get back from the result to the initial form")]),e._v(" "),a("li",[e._v("second pre-image resistance - given some input and output, we'll not find\nanother input with the same output")]),e._v(" "),a("li",[e._v("collision resistance - there are no two different inputs that result in\nthe same output.")])]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("The third property implies the second one. They're quite similar. The difference\nis that "),a("em",[e._v("second pre-image resistance")]),e._v(" requires the input 1 to be fixed.")])]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("Hashing passwords")]),e._v(" "),a("p",[e._v("Argon2 hash function is the best choice for hashing passwords.")])]),e._v(" "),a("h2",{attrs:{id:"mac"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mac"}},[e._v("#")]),e._v(" MAC")]),e._v(" "),a("p",[e._v("Examples: HMAC, KMAC")]),e._v(" "),a("p",[e._v("Uses hash function together with a private key (known to both the sender and the\nreceiver). It's mostly used to verify that the received data is correct (when we\ncreate MAC by ourselves, it matches the received MAC) and sent by authorized\nentity (it had to know the secret to create a MAC). The received data consists\nof raw data and a MAC. The receiver should calculate the MAC from the raw data\nand compare it with the received MAC.")]),e._v(" "),a("p",[e._v("MAc can be used for cookies. After login, we can return a cookie containing a\nMAC of the login name. Since only the server knows the secret that is used to\nproduce a MAC, users cannot provide fake MACs.")]),e._v(" "),a("h3",{attrs:{id:"hmac"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hmac"}},[e._v("#")]),e._v(" HMAC")]),e._v(" "),a("p",[e._v("A way to generate a MAC. It uses a pair of a hashing function and a secret key\nto generate a MAC from some message.")]),e._v(" "),a("p",[e._v("Encryption does not guarantee integrity. The receiver of encrypted data does not\nknow if the received string has not been altered by someone (that someone would\nnot know the plain text, though). It's a good practice to first encrypt the\nplain text and then HMAC it to get a MAC of the encrypted data. A receiver can\ncheck if the encrypted string is correct and then they can decrypt it. Then the\nreceiver would need to know two secrets - HMAC secret and the encryption key.\nOr, a seed might be used.")]),e._v(" "),a("h2",{attrs:{id:"nonce"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nonce"}},[e._v("#")]),e._v(" Nonce")]),e._v(" "),a("p",[e._v("A number attached to the message. There shouldn't be two messages with the same\nnonces. It guards against "),a("em",[e._v("replay attacks")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"symmetric-encryption"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#symmetric-encryption"}},[e._v("#")]),e._v(" Symmetric Encryption")]),e._v(" "),a("p",[e._v("Examples: AES (128, 192, or 256 bits)")]),e._v(" "),a("p",[e._v("The bits in the algorithm name refer to the amount of bits in the key.")]),e._v(" "),a("p",[e._v("AES-128 is commonly used, it provides good enough encryption.")]),e._v(" "),a("h3",{attrs:{id:"authenticated-symmetric-encryption"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#authenticated-symmetric-encryption"}},[e._v("#")]),e._v(" Authenticated Symmetric Encryption")]),e._v(" "),a("p",[e._v("Ciphers generated with AES may be tempered with, and the result of decryption\nmight be invalid. That's why we call it "),a("em",[e._v("Unauthenticated encryption")]),e._v(" - we don't know if the cipher is valid.")]),e._v(" "),a("p",[e._v("Authenticated encryption is used instead to provide some guarantees about\nvalidity of the cipher. AES-GCM and ChaCha20-Poly1305 are used most often.")]),e._v(" "),a("h2",{attrs:{id:"asymmetric-encryption"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#asymmetric-encryption"}},[e._v("#")]),e._v(" Asymmetric Encryption")]),e._v(" "),a("p",[e._v("Examples: Diffie-Hellman (DH), RSA, ECDH (Elliptic Curve DH) (recommended)")]),e._v(" "),a("p",[e._v("Calculating a public key from a private key is simple. The opposite is\ncomputationally infeasible.")]),e._v(" "),a("p",[e._v("Encrypting some data with a private key is called "),a("strong",[e._v("signing")]),e._v(". Everyone can\ndecrypt it, but they can be sure that it was encrypted by the owner of the\nprivate key. It helps to establish trust. If we trust the signer, then we can\ntrust the content of the message that was signed.")]),e._v(" "),a("p",[e._v("Encrypting some data with a public key ensures that only an owner of the private\nkey will be able to read it.")]),e._v(" "),a("p",[e._v("The size of data to be encrypted cannot be too big (~500 characters). Usually,\nthe symmetric key gets encrypted with a public key, and then the parties use\nthat symmetric key to encrypt the actual messages. Additionally, symmetric\nencryption/decryption is much faster than asymmetric operations.")]),e._v(" "),a("h3",{attrs:{id:"authenticated-encryption"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#authenticated-encryption"}},[e._v("#")]),e._v(" Authenticated Encryption")]),e._v(" "),a("p",[e._v("Similarly to symmetric encryption, we need a way to be sure that we got a public\nkey of the entity we believe we got it from. If we don't have a way to verify\nthat then the key exchange is unauthenticated.")]),e._v(" "),a("p",[e._v("Asymmetric communication can be authenticated (one-sided authentication) or\nmutually authenticated.")]),e._v(" "),a("h3",{attrs:{id:"digital-signature"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#digital-signature"}},[e._v("#")]),e._v(" Digital Signature")]),e._v(" "),a("p",[e._v("Signing a piece of data creates a digital signature. It is similar to the MAC.\nSuch a signature provides a proof of "),a("em",[e._v("authenticity")]),e._v(" and "),a("em",[e._v("integrity")]),e._v(" (like MAC).\nAdditionally, it:")]),e._v(" "),a("ul",[a("li",[e._v("allows to verify the signature by anyone. MAC requires the verifier to have\nthe private key")]),e._v(" "),a("li",[e._v("only the trusted sender could generate the signature, because the private key\nwas needed. In case of MAC, both the sender and receiver know the secret. The\nreceiver cannot prove that the MAC was generated by the sender and not the\nreceiver themselves.")])]),e._v(" "),a("p",[e._v("Typically, signatures are created based on digests of the original data due to\nsize limitations in asymmetric encryption. The receiver applies hash to the\nplain text data to compare it with the signed hash.")]),e._v(" "),a("h3",{attrs:{id:"x-509"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#x-509"}},[e._v("#")]),e._v(" X.509")]),e._v(" "),a("p",[e._v("X.509 is a format of digital certificates. It includes:")]),e._v(" "),a("ul",[a("li",[e._v("the public key part of asymmetric pair - that key is being certified")]),e._v(" "),a("li",[e._v("attributes of that key")])]),e._v(" "),a("p",[e._v("The certificate must be signed by a CA (by its private key). CA's public key may\nbe signed by another CA, which creates a hierarchy - a certificate chain. At the\ntop, there's a root certificate, which is trusted unconditionally.")]),e._v(" "),a("p",[e._v("TPM does not generate or consume X.509 certificates. It can store them though.\nThere are some certification processes within TPM:")]),e._v(" "),a("ul",[a("li",[e._v("TPM vendor and platform manufacturer may provision TPM with "),a("strong",[e._v("Endorsement\nKeys")]),e._v(" (EKs) and corresponding certificates before shipping to the end user.\nthe certificates assert respectively that the TPM is produced by the vendor\nand included by the manufacturer in their platform. They are in X.509 format.")]),e._v(" "),a("li",[e._v("the EKs (and their certs) may be used to certify other keys (if EKs are\nsigning). TPM can create certificates (but not in X.509 format, it's too\ncomplex for TPMs).")])]),e._v(" "),a("h2",{attrs:{id:"resources"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#resources"}},[e._v("#")]),e._v(" Resources")]),e._v(" "),a("ul",[a("li",[e._v("Real-World Cryptography by David Wong")]),e._v(" "),a("li",[e._v("http://jrruethe.github.io/blog/2014/10/25/cryptography-primer/")])])])}),[],!1,null,null,null);t.default=s.exports}}]);