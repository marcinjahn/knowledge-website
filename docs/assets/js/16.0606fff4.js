(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{408:function(e,t,a){e.exports=a.p+"assets/img/b-tree.f23e226e.png"},409:function(e,t,a){e.exports=a.p+"assets/img/wrong-b-tree.91cc0893.png"},513:function(e,t,a){"use strict";a.r(t);var r=a(22),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"trees"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#trees"}},[e._v("#")]),e._v(" Trees")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("Dimension")]),e._v(" - maximum amount of children a tree node can have (e.g. binary\ntree - max 2 children)")]),e._v(" "),r("li",[r("strong",[e._v("Height")]),e._v(" of a node - amount of levels from the lowest leaf to that node.")]),e._v(" "),r("li",[r("strong",[e._v("Level")]),e._v(" of a node - tree layers up to that node from the root. The root is\nat level 1.")])]),e._v(" "),r("h2",{attrs:{id:"binary-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#binary-tree"}},[e._v("#")]),e._v(" Binary Tree")]),e._v(" "),r("p",[e._v("A very popular kind of tree is a binary tree, where the dimension parameter\nequals 2.")]),e._v(" "),r("h3",{attrs:{id:"binary-search-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#binary-search-tree"}},[e._v("#")]),e._v(" Binary Search Tree")]),e._v(" "),r("p",[e._v("A binary tree where children with a lesser value are placed on the left, and the\nchildren with greater or equal values are placed on the right.")]),e._v(" "),r("p",[e._v("This tree is well known for the "),r("strong",[e._v("Binary Search")]),e._v(" algorithm that can be applied\nto it (and to sorted arrays).")]),e._v(" "),r("p",[e._v("Characteristics:")]),e._v(" "),r("ul",[r("li",[e._v("the smallest value will be the leaf node on the far left")]),e._v(" "),r("li",[e._v("the greatest value will be the leaf node on the far right")]),e._v(" "),r("li",[e._v("the tree is "),r("strong",[e._v("Balanced")]),e._v(" when:\n"),r("ul",[r("li",[e._v("the right and left side of the root has rougly the same amount of nodes")]),e._v(" "),r("li",[e._v("the height of all leaves is rougly the same")])])]),e._v(" "),r("li",[e._v("the "),r("strong",[e._v("Unbalanced")]),e._v(" tree, in the worst case scenario is like a linked list")])]),e._v(" "),r("h4",{attrs:{id:"complexity"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#complexity"}},[e._v("#")]),e._v(" Complexity")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("Insertion")]),e._v(": O(log n) (average); O(n) (worst case, when the tree is highly\nunbalanced)")]),e._v(" "),r("li",[r("strong",[e._v("Traversal")]),e._v(": O(n)")]),e._v(" "),r("li",[r("strong",[e._v("Lookup")]),e._v(": O(log n) (average); O(n) (worst case, when the tree is highly\nunbalanced)")]),e._v(" "),r("li",[r("strong",[e._v("Removal")]),e._v(": O(log n) (average); O(n) (worst case, when the tree is highly\nunbalanced)")])]),e._v(" "),r("h4",{attrs:{id:"avl"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#avl"}},[e._v("#")]),e._v(" AVL")]),e._v(" "),r("p",[e._v("AVL trees are binary search trees that are self-balancing, keeping the "),r("strong",[e._v("Balance\nFactor")]),e._v(" at maximum 1 at all times.")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("Balance Factor")]),e._v(" "),r("p",[e._v("The "),r("strong",[e._v("Balance Factor")]),e._v(" is the difference between the right and left children on\nthe root node.")])]),e._v(" "),r("h3",{attrs:{id:"traversal"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#traversal"}},[e._v("#")]),e._v(" Traversal")]),e._v(" "),r("h4",{attrs:{id:"pre-order"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#pre-order"}},[e._v("#")]),e._v(" Pre-order")]),e._v(" "),r("p",[e._v("The parent first, then the children.")]),e._v(" "),r("p",[e._v("Use-cases:")]),e._v(" "),r("ul",[r("li",[e._v("creating a copy of a tree (with exactly the same placement of nodes)")])]),e._v(" "),r("h4",{attrs:{id:"in-order"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#in-order"}},[e._v("#")]),e._v(" In-order")]),e._v(" "),r("p",[e._v("The left child is first, then the node, then the right child.")]),e._v(" "),r("p",[e._v("Use-cases:")]),e._v(" "),r("ul",[r("li",[e._v("sorting elements in the increasing order (must be search tree)")])]),e._v(" "),r("h4",{attrs:{id:"post-order"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#post-order"}},[e._v("#")]),e._v(" Post-order")]),e._v(" "),r("p",[e._v("The left and right children are first, then the parent node.")]),e._v(" "),r("p",[e._v("Use-cases:")]),e._v(" "),r("ul",[r("li",[e._v("deleting all nodes of the tree (since we always deal with children first, then\nthe parent)")])]),e._v(" "),r("h2",{attrs:{id:"b-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#b-tree"}},[e._v("#")]),e._v(" B-Tree")]),e._v(" "),r("p",[r("img",{attrs:{src:a(408),alt:""}})]),e._v(" "),r("p",[e._v("Characteristics:")]),e._v(" "),r("ul",[r("li",[e._v("A node can have multiple values")]),e._v(" "),r("li",[e._v("A node can have multiple children")]),e._v(" "),r("li",[e._v("The children are between the values of the node")]),e._v(" "),r("li",[e._v("the tree has to be sorted")]),e._v(" "),r("li",[e._v("For "),r("em",[e._v("n")]),e._v(" values in a node, that node can have "),r("em",[e._v("n+1")]),e._v(" children")]),e._v(" "),r("li",[r("strong",[e._v("Minimal Degree (T)")]),e._v(" "),r("ul",[r("li",[e._v("every non-root node has to have at least "),r("em",[e._v("T")]),e._v(" children and max "),r("em",[e._v("2T")]),e._v(" children")]),e._v(" "),r("li",[e._v("every non-root node has to have at least "),r("em",[e._v("T-1")]),e._v(" values and max "),r("em",[e._v("2T-1")]),e._v(" values")]),e._v(" "),r("li",[e._v("A node with "),r("em",[e._v("T")]),e._v(" children and "),r("em",[e._v("T-1")]),e._v(" values is called a "),r("strong",[e._v("Minimal Node")])]),e._v(" "),r("li",[e._v("a node with "),r("em",[e._v("2T")]),e._v(" children and "),r("em",[e._v("2T-1")]),e._v(" values is a "),r("strong",[e._v("Full Node")])])])]),e._v(" "),r("li",[e._v("All leaf nodes should have the same height")]),e._v(" "),r("li",[e._v("Values can only be added to the leaf nodes")])]),e._v(" "),r("p",[e._v("An example of a tree that is not B-Tree:")]),e._v(" "),r("p",[r("img",{attrs:{src:a(409),alt:""}})]),e._v(" "),r("p",[e._v('The node "1" does not have enough values (should have at least 2).')]),e._v(" "),r("h2",{attrs:{id:"heap"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#heap"}},[e._v("#")]),e._v(" Heap")]),e._v(" "),r("p",[e._v("A tree structure where either:")]),e._v(" "),r("ul",[r("li",[e._v("all children are smaller than or equal to the parent ("),r("strong",[e._v("Max-heap")]),e._v(")")]),e._v(" "),r("li",[e._v("all chidren are greater than or equal to the parent ("),r("strong",[e._v("Min-heap")]),e._v(")")])]),e._v(" "),r("p",[e._v("Thanks to the above ("),r("strong",[e._v("Heap Property")]),e._v(") finding min or max value (depending on\na type of heap) is a O(1) operation.")]),e._v(" "),r("p",[e._v("Additionlly:")]),e._v(" "),r("ul",[r("li",[e._v("The tree must be complete - before starting a new level, the current level\nneeds to be full")]),e._v(" "),r("li",[e._v("Heap can be stored in an array. We just continuously add the nodes from each\nlevel")])])])}),[],!1,null,null,null);t.default=n.exports}}]);