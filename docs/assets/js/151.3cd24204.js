(window.webpackJsonp=window.webpackJsonp||[]).push([[151],{649:function(e,t,a){"use strict";a.r(t);var s=a(22),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"containers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#containers"}},[e._v("#")]),e._v(" Containers")]),e._v(" "),a("h2",{attrs:{id:"namespaces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#namespaces"}},[e._v("#")]),e._v(" Namespaces")]),e._v(" "),a("p",[e._v("Containers rely on namespaces in Linux. There are 8 kinds of namespaces:")]),e._v(" "),a("ul",[a("li",[e._v("cgroups")]),e._v(" "),a("li",[e._v("mount")]),e._v(" "),a("li",[e._v("process ID")]),e._v(" "),a("li",[e._v("network")]),e._v(" "),a("li",[e._v("IPC")]),e._v(" "),a("li",[e._v("UNIX time-sharing system (UTS) - hostname, domain name")]),e._v(" "),a("li",[e._v("users, groups")]),e._v(" "),a("li",[e._v("time")])]),e._v(" "),a("p",[e._v("Each container is assigned with new namespaces of these types, creating an\nillusion for the process that it runs on a separate machine.")]),e._v(" "),a("p",[e._v("Diferent processes may also share some namespace types, but not others:")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://i.imgur.com/ozbsNFE.png",alt:""}})]),e._v(" "),a("h3",{attrs:{id:"networking"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#networking"}},[e._v("#")]),e._v(" Networking")]),e._v(" "),a("p",[e._v("Here's how network namespacing works. When a new container is started, it\nreceives a set of interfaces that are placed in new namespace:")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://i.imgur.com/emBNfbw.png",alt:""}})]),e._v(" "),a("h3",{attrs:{id:"cgroups"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cgroups"}},[e._v("#")]),e._v(" cgroups")]),e._v(" "),a("p",[e._v("cgroups are another feature of Linux kernel. It allows to limit system resources\nassigned to a process (CPU time, CPU cores, RAM, disk, network bandwidth).")]),e._v(" "),a("p",[e._v("When we're setting restrictions for containers (e.g. "),a("code",[e._v('--memory="100m"')]),e._v("),\ncontainer engine actualy uses cgroups to limit the process.")]),e._v(" "),a("h2",{attrs:{id:"capabilities"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#capabilities"}},[e._v("#")]),e._v(" Capabilities")]),e._v(" "),a("p",[e._v("Containers should not be able to invoke sys-calls that may break other\ncontainers (like changing time, or loading kernel modules).")]),e._v(" "),a("p",[e._v("Docker has "),a("code",[e._v("--privileged")]),e._v(" flag that gives special permissions to containers.\nIt's not ideal, because it gives ALL permissions.")]),e._v(" "),a("p",[e._v("Another option is to use Linux "),a("strong",[e._v("capabilities")]),e._v(". There are many of them giivng\ngranular access to specific operations.")]),e._v(" "),a("p",[e._v("Another option is "),a("strong",[e._v("seccomp")]),e._v(" (Secure Computing Mode). A custom profile (JSON\nfile) can be applied to a containers listing sys-calls that it can make.")]),e._v(" "),a("p",[e._v("Further hardening may be achieved with AppArmor or SELinux (MAC).")]),e._v(" "),a("h2",{attrs:{id:"rootless-containers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rootless-containers"}},[e._v("#")]),e._v(" Rootless Containers")]),e._v(" "),a("p",[e._v("Podman popularized the idea of using rootless containers. Previously, it was\ncommon to run containers with Docker with root privileges, which translated to\nroot access on the host as well (although Docker does support rootless\ncontainers as well!).")]),e._v(" "),a("p",[e._v('Rootless containers make use of user namespaces. It gives us access to user\nmapping and allows us to run the container with any UID, even UID = 0, while on\nthe host system that UID would be mapped to a "normal", non-root user.')]),e._v(" "),a("p",[e._v("An easy way to test that is to run "),a("code",[e._v("podman unshare id")]),e._v(". It's going to run "),a("code",[e._v("id")]),e._v('\nprogram in a user namespace. It will print "0" as a result. A non-root user on a\nhost (typically 1000) translates to a root in the namespace.\nWe can see the mapping offsets in the '),a("code",[e._v("/etc/subuid")]),e._v(" file:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("mnj:100000:65536\n")])])]),a("p",[e._v("The output means, that the user 1 in a container will be mapped to user 100000\non a host. User 2 would be mapped to 100001, and so on. A maximum of 65536 users\nmay be mapped (that value may be modified, it's not a hard limit).")]),e._v(" "),a("h3",{attrs:{id:"volumes-and-selinux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volumes-and-selinux"}},[e._v("#")]),e._v(" Volumes and SELinux")]),e._v(" "),a("p",[e._v("Mounting volumes in rootles context is different than it is with rootful\nenvironments. In the latter case, whatever you mount, it will probably just work\nwithout any further tinkering. In rootless podman, you will most likely\nexperience issues with "),a("RouterLink",{attrs:{to:"/technologies/linux/selinux.html"}},[e._v("SELinux")]),e._v(" (if your system uses SELinux\nMAC). One of the ways to get around that is to apply the "),a("code",[e._v(":z")]),e._v(" or "),a("code",[e._v(":Z")]),e._v(" (private,\nadditionally uses MCS) to volume definition. That will apply the right SELinux\nlabeling to the files being shared as a volume (only if we're attaching host\ndir, it is not needed when creating a volume entity).")],1),e._v(" "),a("p",[e._v("Containers run with the "),a("code",[e._v("container_t")]),e._v(" SELinux domain. They are allowed to access\nthe "),a("code",[e._v("container_file_t")]),e._v(" and "),a("code",[e._v("container_ro_file_t")]),e._v(" typed files. The "),a("code",[e._v(":z")]),e._v("/"),a("code",[e._v(":Z")]),e._v("\nparameters apply the "),a("code",[e._v("container_file_t")]),e._v(" to the mounted files.")]),e._v(" "),a("p",[e._v("Another issue could be due to traditional DAC permissions. The user mapping also\nworks for volumes, so a UID 0 in a container will map to UID 1000 on a host. So,\na container will be able to access files of UID 1000 on the host.")]),e._v(" "),a("h2",{attrs:{id:"standarization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#standarization"}},[e._v("#")]),e._v(" Standarization")]),e._v(" "),a("p",[e._v("Docker was the first container platform to make them popular. There's "),a("strong",[e._v("CRI")]),e._v("\n(Container Runtime Interface) that containers platform adhere to.")]),e._v(" "),a("h2",{attrs:{id:"references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),a("ul",[a("li",[e._v('"Kubernetes in Action (Second Edition)" book')]),e._v(" "),a("li",[a("a",{attrs:{href:"https://man7.org/linux/man-pages/man7/namespaces.7.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("man namespaces"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://blog.christophersmart.com/2021/01/26/user-ids-and-rootless-containers-with-podman/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rootless\nContainers"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://www.mankier.com/8/container_selinux",target:"_blank",rel:"noopener noreferrer"}},[e._v("container_selinux"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=n.exports}}]);