(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{426:function(e,t,s){e.exports=s.p+"assets/img/domain-focued-arch.24769a0c.png"},548:function(e,t,s){"use strict";s.r(t);var a=s(22),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"frontmatter-title"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#frontmatter-title"}},[e._v("#")]),e._v(" "+e._s(e.$frontmatter.title))]),e._v(" "),a("h2",{attrs:{id:"projects-organization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#projects-organization"}},[e._v("#")]),e._v(" Projects Organization")]),e._v(" "),a("p",[e._v("Our code could be split into the following projects:")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Domain")]),e._v(" - domain model")]),e._v(" "),a("li",[a("strong",[e._v("Infrastructure")]),e._v(" - dependencies like OS")]),e._v(" "),a("li",[a("strong",[e._v("Persistence")]),e._v(" - database (e.g., repositories)")]),e._v(" "),a("li",[a("strong",[e._v("Application")]),e._v(" - business cases/business logic")]),e._v(" "),a("li",[a("strong",[e._v("Presentation")]),e._v(" - controllers/pages")]),e._v(" "),a("li",[a("strong",[e._v("Common")]),e._v(" - cross-cutting concerns")])]),e._v(" "),a("p",[a("img",{attrs:{src:s(426),alt:""}})]),e._v(" "),a("p",[e._v("The interfaces for various things like database accessshould be stored in the\nApplication layer. The Persistence/Infrastructure should depend on Application\nand contain implementations of the interfaces. It makes sense, because the\ndatabase is the dependency of our Application. It's the Application that\ncontains the use-cases for our solution. Hence, it makes sense to define our\nrequirements (interfaces) in the Application layer. We fulfill these\nrequirements in Persistence/Infrastructure.")]),e._v(" "),a("h2",{attrs:{id:"use-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#use-cases"}},[e._v("#")]),e._v(" Use-Cases")]),e._v(" "),a("p",[e._v("Our Application layer should mostly consist of use-cases that should be\navailable to the users via Presentation layer. These use-cases are basically the\nbusiness logic. We could have:")]),e._v(" "),a("ul",[a("li",[e._v("queries")]),e._v(" "),a("li",[e._v("commands")])]),e._v(" "),a("p",[e._v("This falls a bit into the CQRS topic, but I rather want to focus on the fact\nthat both Commands and Queries are classes for specific use-cases. Within them\nwe'd use the dependencies (like a database) to do the actual work.")]),e._v(" "),a("h2",{attrs:{id:"sources"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sources"}},[e._v("#")]),e._v(" Sources")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://app.pluralsight.com/library/courses/clean-architecture-patterns-practices-principles",target:"_blank",rel:"noopener noreferrer"}},[e._v("Clean Architecture: Patterns, Practices, and Principles\n(Pluralsight)"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://app.pluralsight.com/library/courses/refactoring-anemic-domain-model",target:"_blank",rel:"noopener noreferrer"}},[e._v("Refactoring from Anemic Domain Model Towards a Rich One\n(Pluralsight)"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=r.exports}}]);