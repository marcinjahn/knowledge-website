(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{491:function(t,e,s){"use strict";s.r(e);var a=s(31),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"signatures"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#signatures"}},[t._v("#")]),t._v(" Signatures")]),t._v(" "),s("p",[t._v("Functional programming mainly deals with functions. Function signatures are\ndenoted as follows in the FP community:")]),t._v(" "),s("p",[s("code",[t._v("f: int -> string")])]),t._v(" "),s("p",[t._v("In this case, we have a function called "),s("code",[t._v("f")]),t._v(" that takes an "),s("code",[t._v("int")]),t._v(" as an input and\nreturns a "),s("code",[t._v("string")]),t._v(".")]),t._v(" "),s("p",[t._v("More examples:")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("int -> ()")]),t._v(" - returns "),s("code",[t._v("void")])]),t._v(" "),s("li",[s("code",[t._v("(int, string) -> int")]),t._v(" - takes two parameters")]),t._v(" "),s("li",[s("code",[t._v("(string, (IConnection -> T)) -> T")]),t._v(" - one of the parameters is a function that\ntakes "),s("code",[t._v("IConnection")]),t._v(" and returns "),s("code",[t._v("T")]),t._v(".")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("Signatures of functions (name + parameters + return type) are very important,\nthey should be as expressive as possible.")])]),t._v(" "),s("p",[t._v("Functions that return "),s("code",[t._v("void")]),t._v(" or "),s("code",[t._v("Task")]),t._v(' (or "unit") are side-effect functions.\nThey do something with the "outside world".')]),t._v(" "),s("h2",{attrs:{id:"custom-types"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#custom-types"}},[t._v("#")]),t._v(" Custom Types")]),t._v(" "),s("p",[t._v("It is OK to specify new types for specific purposes, like using "),s("code",[t._v("Age")]),t._v(" instead of\n"),s("code",[t._v("int")]),t._v(" (it also adds to the expressiveness of the signature).")]),t._v(" "),s("h3",{attrs:{id:"honesty"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#honesty"}},[t._v("#")]),t._v(" Honesty")]),t._v(" "),s("p",[t._v("A function is considered "),s("em",[t._v("honest")]),t._v(" if it truly specifies its work in te\nsignature. The function "),s("code",[t._v("Risk CalculateRisk(int age)")]),t._v(" is "),s("em",[t._v("dishonest")]),t._v(", because it\nwill most likely fail if negative age is provided. However, its signature states\nthat any "),s("code",[t._v("int")]),t._v(" is OK.")]),t._v(" "),s("p",[t._v("The function "),s("code",[t._v("Risk CalculateRisk(Age age)")]),t._v(" is "),s("em",[t._v("honest")]),t._v(", because it clearly says\nthat it maps "),s("code",[t._v("Age -> Risk")]),t._v(". Assuming that the "),s("code",[t._v("Age")]),t._v(" type has proper validation\nand cannot be invalid, the function will work with any value of "),s("code",[t._v("Age")]),t._v(".")]),t._v(" "),s("h2",{attrs:{id:"unit-type"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#unit-type"}},[t._v("#")]),t._v(" Unit type")]),t._v(" "),s("p",[t._v("The absence of data can be represented with "),s("code",[t._v("Unit")]),t._v(" instead of "),s("code",[t._v("void")]),t._v(". It's\nsimilar to "),s("RouterLink",{attrs:{to:"/programming/dotnet/functional/programming/rust/basics.html"}},[t._v("Rust's "),s("code",[t._v("()")]),t._v(" type")]),t._v(".")],1),t._v(" "),s("p",[t._v("A problem with "),s("code",[t._v("void")]),t._v(" is that it makes it impossible to treat functions that do\nreturn data similarly as those that don't. If ther is some HOF like this one "),s("code",[t._v("T ExeuteAndLog(Func<T> func)")]),t._v(" we will not be able to invoke it with a "),s("code",[t._v("func")]),t._v(" that\nis an  "),s("code",[t._v("Action")]),t._v(". We'd have to create an overload that accepts "),s("code",[t._v("Action")]),t._v(". It's\nduplication and it sucks.")]),t._v(" "),s("p",[t._v('.NET provides its own "Unit" type - '),s("code",[t._v("System.ValueTuple")]),t._v(" (which makes it even\nmore similar to Rust, since an empty tuple would look like this - "),s("code",[t._v("()")]),t._v(").")]),t._v(" "),s("div",{staticClass:"language-csharp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-csharp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token return-type class-name"}},[t._v("ValueTuple")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("DoSomething")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// an empty tuple")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("Aliasing")]),t._v(" "),s("p",[s("code",[t._v("using Unit = System.ValueType;")]),t._v(" allows for "),s("code",[t._v("Unit")]),t._v(" name to be used.")])]),t._v(" "),s("h2",{attrs:{id:"option"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#option"}},[t._v("#")]),t._v(" Option")]),t._v(" "),s("p",[t._v("In FP we never use "),s("code",[t._v("null")]),t._v(". Instead, "),s("code",[t._v("Option<T>")]),t._v(" is used. It makes signatures\n"),s("RouterLink",{attrs:{to:"/programming/dotnet/functional/signatures.html#honesty"}},[t._v("honest")]),t._v(".")],1),t._v(" "),s("p",[s("code",[t._v("Option<T>")]),t._v(" is a union of "),s("code",[t._v("Some(T)")]),t._v(" and "),s("code",[t._v("None")]),t._v(".")]),t._v(" "),s("p",[t._v(".NET does not have a standard "),s("code",[t._v("Option<T>")]),t._v(" type. Here's a simple implementation:")]),t._v(" "),s("div",{staticClass:"language-csharp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-csharp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("IOption"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("record")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("None"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token type-list"}},[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Option"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// None shouldn't need a T, but the compiler requires it")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("record")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token generic-method"}},[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Some")]),s("span",{pre:!0,attrs:{class:"token generic class-name"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("value")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Option"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("Maybe")]),t._v(" "),s("p",[t._v('Sometimes the "Option" concept is referred to as "Maybe".')])]),t._v(" "),s("p",[t._v("Option pattern is useful for functions that are "),s("em",[t._v("Partial")]),t._v(". Such functions are\nable to return valid data only for some subset of their domain. It's often not\nclear what a function should do if input is outside of that subset - throw an\nexception? Return "),s("code",[t._v("null")]),t._v("? Returning "),s("code",[t._v("None")]),t._v(" is a better way. An example of such a\nfunction could be a function that parses a "),s("code",[t._v("string")]),t._v(" into an "),s("code",[t._v("int")]),t._v(". Not every\nstring is a valid integer.")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("Implicit Type Conversions")]),t._v(" "),s("p",[t._v("C# has a feature that allows one type to be converted to another implicitly. If\na given "),s("code",[t._v("Option")]),t._v(" implementation uses that, it allows "),s("code",[t._v("null")]),t._v(" to be treated as\n"),s("code",[t._v("None")]),t._v(" and "),s("code",[t._v('"data"')]),t._v(" as "),s("code",[t._v("Option<string>")]),t._v(".")])]),t._v(" "),s("p",[t._v("Constructors can also return "),s("code",[t._v("Option<T>")]),t._v(" in case when an object might need some\nvalidation of inputs before creation.")]),t._v(" "),s("h3",{attrs:{id:"nullable-references-in-c-8"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nullable-references-in-c-8"}},[t._v("#")]),t._v(" Nullable references in C# 8")]),t._v(" "),s("p",[t._v("C# 8 brought a way to specify if a reference value can be nullable. It's a bit\nsimilar to the "),s("code",[t._v("Option<T>")]),t._v(", however, it has major drawbacks, the biggest of them\nbeing the fact that it's opt-in and can be entirely skipped. However, it still\nmakes sense to enable it since it gives good warnings when "),s("code",[t._v("null")]),t._v(" might be\nencountered.")]),t._v(" "),s("h3",{attrs:{id:"using-option"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#using-option"}},[t._v("#")]),t._v(" Using Option")]),t._v(" "),s("p",[t._v("Rust-like "),s("code",[t._v("Match")]),t._v(" function can be implemented for consuming "),s("code",[t._v("Option<T>")]),t._v(".")]),t._v(" "),s("p",[t._v("Additionally, it's useful to have a "),s("code",[t._v("Map")]),t._v(" (C#'s "),s("code",[t._v("Select")]),t._v(") function on "),s("code",[t._v("Option<T>")]),t._v(". That way, we can do the following:")]),t._v(" "),s("div",{staticClass:"language-csharp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-csharp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")])]),t._v(" someOption "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("FnThatReturnsOption")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nsomeOption"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("CalculateData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("Without option, we'd do:")]),t._v(" "),s("div",{staticClass:"language-csharp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-csharp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")])]),t._v(" someValue "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("FnThatReturnsValue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("someValue "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("is")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("not")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CalculateData")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("someValue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[s("code",[t._v("Option")]),t._v(" can be seen as a specialized container and treated like an\n"),s("code",[t._v("IEnumerable")]),t._v(". That way we can use the "),s("code",[t._v("Map")]),t._v(" (and "),s("code",[t._v("ForEach")]),t._v(") patterns with them\nthe same way.")]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/programming/dotnet/functional/fundamentals.html#map-vs-foreach"}},[t._v("More about "),s("code",[t._v("Map")]),t._v(" and\n"),s("code",[t._v("ForEach")])])],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);