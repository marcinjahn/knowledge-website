(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{572:function(e,t,o){"use strict";o.r(t);var r=o(22),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"comparisons"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#comparisons"}},[e._v("#")]),e._v(" Comparisons")]),e._v(" "),o("p",[e._v("Comparisons work out-of-box only for primitive types. For others they need to be\ndefined.")]),e._v(" "),o("p",[e._v("Comparisons do not work well with inheritance. It's not recommneded to implement\ncomparisons on unsealed classes.")]),e._v(" "),o("h2",{attrs:{id:"icomparable-t"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#icomparable-t"}},[e._v("#")]),e._v(" "),o("code",[e._v("IComparable<T>")])]),e._v(" "),o("p",[e._v("This interface defines "),o("code",[e._v("CompareTo")]),e._v(" method that returns "),o("code",[e._v("int")]),e._v(":")]),e._v(" "),o("ul",[o("li",[e._v("-1 (less then)")]),e._v(" "),o("li",[e._v("0 (equal)")]),e._v(" "),o("li",[e._v("+1 (greater then)")])]),e._v(" "),o("p",[e._v("It's also recommended to implement non-generic "),o("code",[e._v("IComparable")]),e._v(" for legacy code.")]),e._v(" "),o("p",[e._v("This interface is used by arrays to sort its items - if item does not implement,\nexception will be thrown.")]),e._v(" "),o("h2",{attrs:{id:"operators"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#operators"}},[e._v("#")]),e._v(" Operators")]),e._v(" "),o("p",[e._v("There are 4 operators that can be implemented: <, <=, >, >=. If these get\nimplemented, it's recommended to also implement == (and !=).")]),e._v(" "),o("h2",{attrs:{id:"icomparer-t"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#icomparer-t"}},[e._v("#")]),e._v(" "),o("code",[e._v("IComparer<T>")])]),e._v(" "),o("p",[e._v("Interface to be implemented by classes that can compare "),o("code",[e._v("T")]),e._v(". When implementing\nit there's a convention:")]),e._v(" "),o("ul",[o("li",[e._v("it two objects are "),o("code",[e._v("NULL")]),e._v(' return "0"')]),e._v(" "),o("li",[e._v("if first object is "),o("code",[e._v("NULL")]),e._v(', return "-1"')]),e._v(" "),o("li",[e._v("if second object is "),o("code",[e._v("NULL")]),e._v(', return "+1"')])]),e._v(" "),o("p",[e._v("There is actually a recomendation to inherit from "),o("code",[e._v("Comparer<T>")]),e._v(" base class\ninstead of implementing the interface from zero (because it also implements\nnon-generic "),o("code",[e._v("IComparer")]),e._v(", which makes it easier for our class).")]),e._v(" "),o("p",[e._v("Comparers are good candidates for singletons.")]),e._v(" "),o("p",[e._v("A good comparer should be deterministic and the reuslt should not depend on the\ninput order. For example, if a class has 2 properties and our comparer sorts\nthem by one of these properties, it might happen that two instances will be\nconsidered equal when their second property has different values. So, our\ncomparer should actually also look at the value of second property when first\nproperty values are equal.")]),e._v(" "),o("p",[e._v("Writing comparers for non-sealed classes is problematic, mostly due to the\nproblem outlined in previous paragraph. The result of sorting will depend from\norder of input elements since the comparer does not know anything about the\ninheriting instances (unles it actually does). There is no real solution for\nthis issue.")]),e._v(" "),o("p",[o("code",[e._v("Comparer<T>.Default")]),e._v(" every type can use the default comparer, which uses the\nT's "),o("code",[e._v("IComparer<T>")]),e._v(" implementation (or "),o("code",[e._v("IComparer")]),e._v(" if generic one is missing).\nWhat if both are missing? An exception?")]),e._v(" "),o("p",[o("code",[e._v("StringComparer")]),e._v(" is a static class that has 6 various comparers for strings\n(implements "),o("code",[e._v("IComparer")]),e._v(" and "),o("code",[e._v("IEqualityComparer")]),e._v(").")])])}),[],!1,null,null,null);t.default=s.exports}}]);