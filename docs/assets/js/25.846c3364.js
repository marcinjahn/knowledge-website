(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{455:function(e,t,a){e.exports=a.p+"assets/img/deployment-replicaset-selector.249cfc6d.png"},473:function(e,t,a){"use strict";a.r(t);var s=a(22),o=function(e){e.options.__data__block__={mermaid_382ee1e4:"flowchart LR\n    A[Deployment] --\x3e |manages| B[ReplicaSet] --\x3e |manages| C[Pod]\n    B --\x3e |manages| D[Pod]\n"}},i=Object(s.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"scaling"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#scaling"}},[e._v("#")]),e._v(" Scaling")]),e._v(" "),s("p",[e._v("It's not very convenient to manage pods individually. We need ways to deploy\npods in multiple replicas, which is a base for high availability of the service.\nAdditionally, we need a way to keep pods running in case some node fails.")]),e._v(" "),s("h2",{attrs:{id:"replicaset"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#replicaset"}},[e._v("#")]),e._v(" ReplicaSet")]),e._v(" "),s("p",[e._v("ReplicaSet allows us to create a group of pod replicas, instead of just one pod.\nThe pods managed by the ReplicaSet are selected using an immutable label\nselector (similarly to "),s("RouterLink",{attrs:{to:"/technologies/kubernetes/services.html"}},[e._v("Services")]),e._v("). There is also a template,\nwhich defines the pod(s) that will be created under ReplicaSet. Such a pod has\nto conform to the "),s("em",[e._v("selector")]),e._v(" specified by the ReplicaSet.")],1),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("Existing Pods")]),e._v(" "),s("p",[e._v("If some pods matching the selector already existed prior to the creation of the\nReplicaSet, they're counted as part of the ReplicaSet.")]),e._v(" "),s("p",[e._v("If we manually create some pod(s) that conform to ReplicaSet's selector, the\ncontroller will delete some pods to reach the "),s("em",[e._v("replicas")]),e._v(" count.")])]),e._v(" "),s("p",[e._v("Pod names are generated based on the ReplicaSet's name, but it can be changed\nwith the "),s("code",[e._v("generateName")]),e._v(" setting.")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("ReplicationController")]),e._v(" "),s("p",[e._v("In the past, ReplicationController was used instead of ReplicaSet. It behaved\nthe same as ReplicaSet does. It is now deprecated.")])]),e._v(" "),s("p",[e._v("ReplicaSets are rarely used directly due to their lacking pods updates\npossibilities.")]),e._v(" "),s("h3",{attrs:{id:"updates"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#updates"}},[e._v("#")]),e._v(" Updates")]),e._v(" "),s("p",[e._v("We're free to change "),s("code",[e._v("replicas")]),e._v(" count and the number of pods will reflect the\nsetting.")]),e._v(" "),s("p",[e._v("If we modify the "),s("code",[e._v("template")]),e._v(" of some existing ReplicaSet, the existing pods will\nnot be updated. Instead, just the pods created by ReplicaSet in the future will\nhave the new settings applied.")]),e._v(" "),s("h3",{attrs:{id:"replacing-a-pod"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#replacing-a-pod"}},[e._v("#")]),e._v(" Replacing a Pod")]),e._v(" "),s("p",[e._v("Sometimes we might want to investigate some issue in one of the pods, while\nkeeping ReplicaSet running with proper scaling. We could temporarily increment\nthe "),s("em",[e._v("replicas")]),e._v(" config, but we'd have to rememeber to decrement it back later on.\nInstead, we can just change the labels of the faulty pod so that it does not\nconform to ReplicaSet's selector. The ReplicaSet's controller will create a new\npod for its needs while we can start investigating the faulty pod.")]),e._v(" "),s("h3",{attrs:{id:"ownership"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ownership"}},[e._v("#")]),e._v(" Ownership")]),e._v(" "),s("p",[e._v('Pods managed by a ReplicaSet have a special "ownerReference" section in\ntheir "metadata". A pod can have multiple owners.')]),e._v(" "),s("p",[e._v("Pods are auto-deleted when the owners are deleted (unless the "),s("code",[e._v("--cascade=orphan")]),e._v("\nparameter is applied while removing the owner).")]),e._v(" "),s("p",[e._v("If a pod is taken out of the ReplicaSet (like "),s("a",{attrs:{href:"#replacing-a-pod"}},[e._v("this")]),e._v(') the\n"ownerReference" metadata is deleted from it automatically.')]),e._v(" "),s("h2",{attrs:{id:"deployment"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#deployment"}},[e._v("#")]),e._v(" Deployment")]),e._v(" "),s("p",[e._v("Deployments manage Pods via a ReplicaSet. They are mostly used for stateless\nworkloads.")]),e._v(" "),s("Mermaid",{attrs:{id:"mermaid_382ee1e4",graph:e.$dataBlock.mermaid_382ee1e4}}),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("ReplicaSet Updates")]),e._v(" "),s("p",[e._v("If we try to edit ReplicaSet managed by a Deployment, our updates will be\nreplaced with Deployment's config soon after. ReplicaSet is controlled by the\nDeployment and we should modify its settings throught the Deployment.")])]),e._v(" "),s("p",[e._v("In addition to settings available to ReplicaSets, Deployments also contain the\n"),s("code",[e._v("strategy")]),e._v(" configuration. It dictates how Pods are replaced during updates.")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("Existing Pods")]),e._v(" "),s("p",[e._v("If some pods already exist that match the Deployment's selector, most likely\nthey will not be reused in the Deployment's replicas. The ReplicaSet managed by\nthe Deployment adds additional (\"random\") label requirement to the pods it\nmanages.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(455),alt:""}})])]),e._v(" "),s("h3",{attrs:{id:"updates-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#updates-2"}},[e._v("#")]),e._v(" Updates")]),e._v(" "),s("p",[e._v("Compared to ReplicaSets, updating Pod template causes all the existing Pods to\nbe redeployed to meet the new requirements. Anytime we update Pod's template a\nhash of it is calculated, and a new ReplicaSet is created with that hash being\nused for one of the selectors.")]),e._v(" "),s("h3",{attrs:{id:"example"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#example"}},[e._v("#")]),e._v(" Example")]),e._v(" "),s("p",[e._v("Creating a simple deployment: "),s("code",[e._v("kubectl create deployment kiada --image=luksa/kiada:0.1")])]),e._v(" "),s("p",[e._v("Kubectl sends a POST request to "),s("code",[e._v("/deployments")]),e._v(" of K8s API to create a\n"),s("em",[e._v("Deployment")]),e._v(" object. Kubernetes creates a "),s("em",[e._v("Pod")]),e._v(" object based on Deployment. The\npod is assigned to a Worker Node. Kubelet on a worker node pulls the image and\nruns the container.")]),e._v(" "),s("p",[e._v("We can track a deployment with "),s("code",[e._v("k rollout status deployment my-deployment")]),e._v(".")]),e._v(" "),s("h3",{attrs:{id:"scaling-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#scaling-2"}},[e._v("#")]),e._v(" Scaling")]),e._v(" "),s("p",[s("code",[e._v("kubectl scale deployment kiada --replicas=3")])]),e._v(" "),s("h2",{attrs:{id:"pods-deletion"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pods-deletion"}},[e._v("#")]),e._v(" Pods Deletion")]),e._v(" "),s("p",[e._v("When scaling down, K8s selects pods to delete based on some priorities:")]),e._v(" "),s("ul",[s("li",[e._v("pods that are not started")]),e._v(" "),s("li",[e._v("pods collocated on the same node with greater number of replicas")]),e._v(" "),s("li",[e._v("pods that lived shorter")]),e._v(" "),s("li",[e._v("pods with a greater number of restarts")])]),e._v(" "),s("p",[e._v("We can also influence the priority by applying "),s("code",[e._v("pod-deletion-cost")]),e._v(" annotation to\nspecific pods.")]),e._v(" "),s("h2",{attrs:{id:"logs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#logs"}},[e._v("#")]),e._v(" Logs")]),e._v(" "),s("p",[e._v("There is no easy way to display logs from all the pods in a ReplicaSet/Deployment.\nInstead, we have to use label selector:")]),e._v(" "),s("div",{staticClass:"language-sh extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[e._v("k logs -l "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("app")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("myapp --prefix --all-containers\n")])])]),s("ul",[s("li",[s("code",[e._v("--prefix")]),e._v(" prefixes each log with the container that it came from")]),e._v(" "),s("li",[s("code",[e._v("--all-containers")]),e._v(" displays logs from all containers of the pods")])])],1)}),[],!1,null,null,null);"function"==typeof o&&o(i);t.default=i.exports}}]);