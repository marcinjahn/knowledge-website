(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{513:function(t,s,a){"use strict";a.r(s);var e=a(31),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"signatures"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#signatures"}},[t._v("#")]),t._v(" Signatures")]),t._v(" "),a("p",[t._v("Functional programming mainly deals with functions. Function signatures are\ndenoted as follows in the FP community:")]),t._v(" "),a("p",[a("code",[t._v("f: int -> string")])]),t._v(" "),a("p",[t._v("In this case, we have a function called "),a("code",[t._v("f")]),t._v(" that takes an "),a("code",[t._v("int")]),t._v(" as an input and\nreturns a "),a("code",[t._v("string")]),t._v(".")]),t._v(" "),a("p",[t._v("More examples:")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("int -> ()")]),t._v(" - returns "),a("code",[t._v("void")])]),t._v(" "),a("li",[a("code",[t._v("(int, string) -> int")]),t._v(" - takes two parameters")]),t._v(" "),a("li",[a("code",[t._v("(string, (IConnection -> T)) -> T")]),t._v(" - one of the parameters is a function that\ntakes "),a("code",[t._v("IConnection")]),t._v(" and returns "),a("code",[t._v("T")]),t._v(".")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("Signatures of functions (name + parameters + return type) are very important,\nthey should be as expressive as possible.")])]),t._v(" "),a("p",[t._v("Functions that return "),a("code",[t._v("void")]),t._v(" or "),a("code",[t._v("Task")]),t._v(' (or "unit") are side-effect functions.\nThey do something with the "outside world".')]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Arguments order")]),t._v(" "),a("p",[t._v("For the functions to be usable with "),a("RouterLink",{attrs:{to:"/programming/dotnet/functional/partial-application.html"}},[t._v("Patrial\nApplication")]),t._v(", it makes sense to order the arguments\nfrom the most generic ones to the most specific ones.")],1),t._v(" "),a("div",{staticClass:"language-csharp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-csharp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// GOOD - Apply can be easily used")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token return-type class-name"}},[t._v("Person")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Query")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("string")])]),t._v(" connectionString"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("string")])]),t._v(" sql"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// BAD - we'd have to apply something like ApplyR to have common connection string")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token return-type class-name"}},[t._v("Person")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Query")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("string")])]),t._v(" sql"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("string")])]),t._v(" connectionString"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])]),t._v(" "),a("h2",{attrs:{id:"custom-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#custom-types"}},[t._v("#")]),t._v(" Custom Types")]),t._v(" "),a("p",[t._v("It is OK to specify new types for specific purposes, like using "),a("code",[t._v("Age")]),t._v(" instead of\n"),a("code",[t._v("int")]),t._v(" (it also adds to the expressiveness of the signature).")]),t._v(" "),a("h3",{attrs:{id:"honesty"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#honesty"}},[t._v("#")]),t._v(" Honesty")]),t._v(" "),a("p",[t._v("A function is considered "),a("em",[t._v("honest")]),t._v(" if it truly specifies its work in te\nsignature. The function "),a("code",[t._v("Risk CalculateRisk(int age)")]),t._v(" is "),a("em",[t._v("dishonest")]),t._v(", because it\nwill most likely fail if negative age is provided. However, its signature states\nthat any "),a("code",[t._v("int")]),t._v(" is OK.")]),t._v(" "),a("p",[t._v("The function "),a("code",[t._v("Risk CalculateRisk(Age age)")]),t._v(" is "),a("em",[t._v("honest")]),t._v(", because it clearly says\nthat it maps "),a("code",[t._v("Age -> Risk")]),t._v(". Assuming that the "),a("code",[t._v("Age")]),t._v(" type has proper validation\nand cannot be invalid, the function will work with any value of "),a("code",[t._v("Age")]),t._v(".")]),t._v(" "),a("h2",{attrs:{id:"unit-type"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unit-type"}},[t._v("#")]),t._v(" Unit type")]),t._v(" "),a("p",[t._v("The absence of data can be represented with "),a("code",[t._v("Unit")]),t._v(" instead of "),a("code",[t._v("void")]),t._v(". It's\nsimilar to "),a("RouterLink",{attrs:{to:"/programming/dotnet/functional/programming/rust/basics.html"}},[t._v("Rust's "),a("code",[t._v("()")]),t._v(" type")]),t._v(".")],1),t._v(" "),a("p",[t._v("A problem with "),a("code",[t._v("void")]),t._v(" is that it makes it impossible to treat functions that do\nreturn data similarly as those that don't. If ther is some HOF like this one "),a("code",[t._v("T ExeuteAndLog(Func<T> func)")]),t._v(" we will not be able to invoke it with a "),a("code",[t._v("func")]),t._v(" that\nis an  "),a("code",[t._v("Action")]),t._v(". We'd have to create an overload that accepts "),a("code",[t._v("Action")]),t._v(". It's\nduplication and it sucks.")]),t._v(" "),a("p",[t._v('.NET provides its own "Unit" type - '),a("code",[t._v("System.ValueTuple")]),t._v(" (which makes it even\nmore similar to Rust, since an empty tuple would look like this - "),a("code",[t._v("()")]),t._v(").")]),t._v(" "),a("div",{staticClass:"language-csharp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-csharp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token return-type class-name"}},[t._v("ValueTuple")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("DoSomething")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// an empty tuple")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Aliasing")]),t._v(" "),a("p",[a("code",[t._v("using Unit = System.ValueType;")]),t._v(" allows for "),a("code",[t._v("Unit")]),t._v(" name to be used.")])]),t._v(" "),a("h2",{attrs:{id:"option"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#option"}},[t._v("#")]),t._v(" Option")]),t._v(" "),a("p",[t._v("In FP we never use "),a("code",[t._v("null")]),t._v(". Instead, "),a("code",[t._v("Option<T>")]),t._v(" is used. It makes signatures\n"),a("RouterLink",{attrs:{to:"/programming/dotnet/functional/signatures.html#honesty"}},[t._v("honest")]),t._v(".")],1),t._v(" "),a("p",[a("code",[t._v("Option<T>")]),t._v(" is a union of "),a("code",[t._v("Some(T)")]),t._v(" and "),a("code",[t._v("None")]),t._v(".")]),t._v(" "),a("p",[t._v(".NET does not have a standard "),a("code",[t._v("Option<T>")]),t._v(" type. Here's a simple implementation:")]),t._v(" "),a("div",{staticClass:"language-csharp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-csharp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("IOption"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("record")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("None"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token type-list"}},[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Option"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// None shouldn't need a T, but the compiler requires it")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("record")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token generic-method"}},[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Some")]),a("span",{pre:!0,attrs:{class:"token generic class-name"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("value")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Option"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("Maybe")]),t._v(" "),a("p",[t._v('Sometimes the "Option" concept is referred to as "Maybe".')])]),t._v(" "),a("p",[t._v("Option pattern is useful for functions that are "),a("em",[t._v("Partial")]),t._v(". Such functions are\nable to return valid data only for some subset of their domain. It's often not\nclear what a function should do if input is outside of that subset - throw an\nexception? Return "),a("code",[t._v("null")]),t._v("? Returning "),a("code",[t._v("None")]),t._v(" is a better way. An example of such a\nfunction could be a function that parses a "),a("code",[t._v("string")]),t._v(" into an "),a("code",[t._v("int")]),t._v(". Not every\nstring is a valid integer.")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Implicit Type Conversions")]),t._v(" "),a("p",[t._v("C# has a feature that allows one type to be converted to another implicitly. If\na given "),a("code",[t._v("Option")]),t._v(" implementation uses that, it allows "),a("code",[t._v("null")]),t._v(" to be treated as\n"),a("code",[t._v("None")]),t._v(" and "),a("code",[t._v('"data"')]),t._v(" as "),a("code",[t._v("Option<string>")]),t._v(".")])]),t._v(" "),a("p",[t._v("Constructors can also return "),a("code",[t._v("Option<T>")]),t._v(" in case when an object might need some\nvalidation of inputs before creation.")]),t._v(" "),a("h3",{attrs:{id:"nullable-references-in-c-8"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nullable-references-in-c-8"}},[t._v("#")]),t._v(" Nullable references in C# 8")]),t._v(" "),a("p",[t._v("C# 8 brought a way to specify if a reference value can be nullable. It's a bit\nsimilar to the "),a("code",[t._v("Option<T>")]),t._v(", however, it has major drawbacks, the biggest of them\nbeing the fact that it's opt-in and can be entirely skipped. However, it still\nmakes sense to enable it since it gives good warnings when "),a("code",[t._v("null")]),t._v(" might be\nencountered.")]),t._v(" "),a("h3",{attrs:{id:"using-option"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#using-option"}},[t._v("#")]),t._v(" Using Option")]),t._v(" "),a("p",[t._v("Rust-like "),a("code",[t._v("Match")]),t._v(" function can be implemented for consuming "),a("code",[t._v("Option<T>")]),t._v(".")]),t._v(" "),a("p",[t._v("Additionally, it's useful to have a "),a("code",[t._v("Map")]),t._v(" (C#'s "),a("code",[t._v("Select")]),t._v(") function on "),a("code",[t._v("Option<T>")]),t._v(". That way, we can do the following:")]),t._v(" "),a("div",{staticClass:"language-csharp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-csharp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")])]),t._v(" someOption "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("FnThatReturnsOption")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nsomeOption"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Map")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("CalculateData"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("Without option, we'd do:")]),t._v(" "),a("div",{staticClass:"language-csharp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-csharp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")])]),t._v(" someValue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("FnThatReturnsValue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("someValue "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("is")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("not")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("CalculateData")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("someValue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[a("code",[t._v("Option")]),t._v(" can be seen as a specialized container and treated like an\n"),a("code",[t._v("IEnumerable")]),t._v(". That way we can use the "),a("code",[t._v("Map")]),t._v(" (and "),a("code",[t._v("ForEach")]),t._v(") patterns with them\nthe same way.")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/programming/dotnet/functional/fundamentals.html#map-vs-foreach"}},[t._v("More about "),a("code",[t._v("Map")]),t._v(" and\n"),a("code",[t._v("ForEach")])])],1)])])}),[],!1,null,null,null);s.default=n.exports}}]);