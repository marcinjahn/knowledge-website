(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{515:function(e,t,a){"use strict";a.r(t);var s=a(22),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"frontmatter-title"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#frontmatter-title"}},[e._v("#")]),e._v(" "+e._s(e.$frontmatter.title))]),e._v(" "),a("p",[e._v("The Domain-Driven Design (DDD) is an architecture style for building\nmicroservices-based software systems. Some argue that microservices architecture\nis true only with DDD.")]),e._v(" "),a("p",[e._v("The main goal of DDD is to make software more maintainable, to make it less\ncomplex to deal with.")]),e._v(" "),a("h2",{attrs:{id:"bounded-context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bounded-context"}},[e._v("#")]),e._v(" Bounded Context")]),e._v(" "),a("p",[e._v("As part of DDD, we identify "),a("strong",[e._v("Subdomains")]),e._v(" that take part in our system.\nSubdomain is a subset of some larger "),a("strong",[e._v("Domain")]),e._v(". The terms are rather fuzzy.\nEvery subdomain is some domain itself after all. Domains and subdomains are a\nhierarchical concept.")]),e._v(" "),a("p",[e._v("When we design DDD-compliant system, the domain is the general problem we're\ntrying to solve, let's say \"Monitoring of IoT Platform Instances\". This great\ndomain may be splitted into smaller concerns - subdomains:")]),e._v(" "),a("ul",[a("li",[e._v("users management")]),e._v(" "),a("li",[e._v("platforms management")]),e._v(" "),a("li",[e._v("notifications")]),e._v(" "),a("li",[e._v("etc.")])]),e._v(" "),a("p",[e._v("A "),a("strong",[e._v("Bounded Context")]),e._v(" represents a linguistic boundary within or across\nsubdomains. Often, a Bounded Context is aligned with a Subdomain. The difference\nbetween these two concepts is as follows:")]),e._v(" "),a("ul",[a("li",[e._v("a "),a("strong",[e._v("Subdomain")]),e._v(" is in the "),a("em",[e._v("Problem Space")]),e._v(".")]),e._v(" "),a("li",[e._v("a "),a("strong",[e._v("Bounded Context")]),e._v(" is in the "),a("em",[e._v("Solution Space")]),e._v(".")])]),e._v(" "),a("p",[e._v("So, a given bounded context is a proposed solution to a problem within some\nsubdomain.")]),e._v(" "),a("p",[e._v("In a typical project, there will be many bounded contexts. Ideally, each of them\nshould be developed by a different team. Each would also use a separate data\nstore.")]),e._v(" "),a("h3",{attrs:{id:"bounded-context-vs-microservice"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bounded-context-vs-microservice"}},[e._v("#")]),e._v(" Bounded Context vs Microservice")]),e._v(" "),a("p",[e._v("There isn't a 1:1 relation between a bounded context and a microservice. A\nsingle bounded context could be served by multiple microservices. For example,\none microservice could be in a form of an HTTP API, serving requests. Another\nmicroservice could be a listener on some bus. Both could work on the same\ndatabase, but they'd work on a different parts of the overall responsibility of\nthe bounded context.")]),e._v(" "),a("h3",{attrs:{id:"ubiquitous-language"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ubiquitous-language"}},[e._v("#")]),e._v(" Ubiquitous Language")]),e._v(" "),a("p",[e._v("One of the pillars of DDD is the establishment of the "),a("strong",[e._v("Ubiquitous Language")]),e._v(" -\nan agreed vocabulary that will be used to describe various entities in the\nBounded Contexts. It should be used everywhere in the project: code, diagrams,\ndiscussions, etc.")]),e._v(" "),a("p",[e._v("Every context will have its own ubiquitous language.")]),e._v(" "),a("h4",{attrs:{id:"context-maps"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context-maps"}},[e._v("#")]),e._v(" Context Maps")]),e._v(" "),a("p",[e._v("The namings in different Bounded Contexts and their relations is what defines\n"),a("strong",[e._v("Context Maps")]),e._v(". It could be that different Bounded Contexts use the same name\nfor different entities. It could also happen that different bounded context\nwould model the same entity (like a Customer in Appointment Scheduler context\nand Customer in the Billing context).")]),e._v(" "),a("p",[e._v("A Context Map clearly shows what a given entity is represented by in another\ncontext.")]),e._v(" "),a("h3",{attrs:{id:"synchronization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronization"}},[e._v("#")]),e._v(" Synchronization")]),e._v(" "),a("p",[e._v("Different bounded context may model data for the same physical entity. For\nexample, Patient Management context and scheduling context may contain the\nPatient entity. Probably, the one in the Patient Management context will be more\ndetailed. Also, probably that one will allow for various modifications. E.g., we\ncould change the patient's name. The other contexts that model the Patient\nshould be notified about this change. E.g., it could be done via some message\nbus. The Patient Management service would publish a message about the change,\nand all other interested services would be listeners.")]),e._v(" "),a("h2",{attrs:{id:"domain-model"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#domain-model"}},[e._v("#")]),e._v(" Domain Model")]),e._v(" "),a("p",[e._v("Designing our domain model is crucial. According to Eric Evans:")]),e._v(" "),a("blockquote",[a("p",[e._v("The domain is the heart of business software.")])]),e._v(" "),a("p",[e._v("Another point is that models evolve over time. Our initial assumptions can be\noften invalidated as we progress in understanding the domain.")]),e._v(" "),a("p",[e._v("In our modeling, we should focus on the behaviours of the models. To find such\nbehaviours, we need to look at all the possible events that may occur in the\nsystem - those events are basically the use-cases that the solution is expected\nto fulfill. Some examples of these events could be (in medical clinic system):")]),e._v(" "),a("ul",[a("li",[e._v("add a new patient")]),e._v(" "),a("li",[e._v("schedule a visit")]),e._v(" "),a("li",[e._v("move a visit to another date")])]),e._v(" "),a("h3",{attrs:{id:"rich-domain-models"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rich-domain-models"}},[e._v("#")]),e._v(" Rich Domain Models")]),e._v(" "),a("p",[e._v("DDD encourages the use of "),a("strong",[e._v("Rich Domain Models")]),e._v(", opposed to the "),a("strong",[e._v("Anemic Domain\nModels")]),e._v(". Anemic models are simply classes that are DTOs, or classes with very\nlittle logic inside of them.")]),e._v(" "),a("p",[e._v("Often in our programs we have DTO classes and other service classes that act on\nthese DTOs, potentially modifying them. This is an anti-pattern in the DDD\nworld. Martin Fowler argues that this is even an anti-pattern in the OOP sense,\nsince OOP is supposed to merge data and behaviour together.")]),e._v(" "),a("h3",{attrs:{id:"entities"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entities"}},[e._v("#")]),e._v(" Entities")]),e._v(" "),a("p",[e._v("These are objects defined by their identity. That means that every instance of\nan Entity is unique, it has its own key. identifier. Examples of entities:")]),e._v(" "),a("ul",[a("li",[e._v("Patient")]),e._v(" "),a("li",[e._v("Doctor")]),e._v(" "),a("li",[e._v("Room")]),e._v(" "),a("li",[e._v("Appointment")])]),e._v(" "),a("p",[e._v("An entity should always be in the valid state. Hence any modification of an\nentity (or its creation) should contain various guard clauses that make sure the\noperation can be done. For example, before I rename a Patient, I should make\nsure that the new name is not empty.")]),e._v(" "),a("p",[e._v("Entities also contain "),a("em",[e._v("Events")]),e._v(". These may be used to inform other parts of the\nsystem of changes.")]),e._v(" "),a("h3",{attrs:{id:"value-objects"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#value-objects"}},[e._v("#")]),e._v(" Value Objects")]),e._v(" "),a("p",[e._v("Identity of "),a("strong",[e._v("Value Objects")]),e._v(" is based on composition of its values. They're\nimmutable. Value objects may contain methods (without side-effects).")]),e._v(" "),a("p",[e._v("Value Objects are basically non-identified types that are specific to our\nsub-domain. They group together some related data. Examples include:")]),e._v(" "),a("ul",[a("li",[e._v("money")]),e._v(" "),a("li",[e._v("date range")])]),e._v(" "),a("p",[e._v("An instance of a value object does not represent any unique entity, it's just a\nset of information representing something in our domain.")]),e._v(" "),a("p",[e._v("It's recommended to first consider Value Object when deciding whether to use\n"),a("a",{attrs:{href:"#entities"}},[e._v("Entity")]),e._v(" or Value Object for a given thing.")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("Identifiers")]),e._v(" "),a("p",[e._v("In some projects identifiers of Entities are value objects. These are custom\ntypes that contain just an identifier (for example as a "),a("code",[e._v("Guid")]),e._v("). So, we could\nhave a type called "),a("code",[e._v("CustomerIdValueObject")]),e._v(". Some argue that it makes the\nsolution more explicit, but I don't really agree with that. I think it\ncomplicates things more than necessary.")]),e._v(" "),a("div",{staticClass:"language-cs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cs"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Supposedly, these types help to not pass arguments in the wrong order")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token return-type class-name"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("CreateAppointment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ClientId")]),e._v(" clientId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("DoctorId")]),e._v(" doctorId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])])]),e._v(" "),a("p",[e._v("Date types are a great example of value objects.")]),e._v(" "),a("h3",{attrs:{id:"domain-services"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#domain-services"}},[e._v("#")]),e._v(" Domain Services")]),e._v(" "),a("p",[e._v("Logic/behaviour that doesn't fit into Entities or Value Objects goes into\nseparate classes called "),a("strong",[e._v("Domain Services")]),e._v(". Such services often deal with\ndifferent kinds of entities/value objects. For example, they could orchestrate\nsome workflow.")]),e._v(" "),a("p",[e._v("Also infrastructure-level logic, like logging, sending notifications, etc. is\nconsidered to be in the Doman Services area.")]),e._v(" "),a("p",[e._v("Before creating a service, we should make sure that the logic we're adding\ndoesn't fit into any of the existing domain elements (entities/value objects).")]),e._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[e._v("WARNING")]),e._v(" "),a("p",[e._v("Overuse of domain services might lead to anemic models.")])]),e._v(" "),a("h3",{attrs:{id:"aggregates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aggregates"}},[e._v("#")]),e._v(" Aggregates")]),e._v(" "),a("p",[e._v("When building our Entities we will often end up with "),a("strong",[e._v("Aggregate")]),e._v(" entities,\nthat is, entities that are linked with other entities or value objects.")]),e._v(" "),a("p",[e._v("Citing "),a("a",{attrs:{href:"https://martinfowler.com/bliki/DDD_Aggregate.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Martin Fowler"),a("OutboundLink")],1),e._v(":")]),e._v(" "),a("blockquote",[a("p",[e._v("A DDD aggregate is a cluster of domain objects that can be treated as a single\nunit. An example may be an order and its line-items, these will be separate\nobjects, but it's useful to treat the order (together with its line items) as\na single aggregate.")])]),e._v(" "),a("p",[e._v("There will also be an "),a("strong",[e._v("Aggreagate Root")]),e._v(' - an entry point of an aggregate that\n"defines" the aggregate as a whole. To find out what is an aggregate root, we\nneed to look at individual components and think if the removal of a given\ncomponent would result in removal of its contained components. (cascading\ndelete) If it would, that\'s probably an Aggregate Root.')]),e._v(" "),a("p",[e._v("Aggregate Root is like a central entity that defines it completely. It should\nallow us to keep the whole object in a valid state (enforcing invariants). We\nshould modify the aggregate only throught the Aggregate Root. The root will make\nsure that the invariants are satisfied.")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("There will also be entities that do not include other entities or value objects.\nThe convention is to call these Aggreagtes as well.")])]),e._v(" "),a("p",[e._v("How many aggregate roots should there be in a single bounded context?")]),e._v(" "),a("h3",{attrs:{id:"associations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#associations"}},[e._v("#")]),e._v(" Associations")]),e._v(" "),a("p",[e._v("DDD encourages one-way relations between entities. It's popular in Entity\nFramework to define navigation properties in both ways. It turns out it's not\nalways needed. It makes entities more complex. By default, we should start our\nmodeling with uni-directional relationships and switch to bi-directional ones\nonly when necessary.")]),e._v(" "),a("p",[e._v('It still is OK to keep an identifier of the other entity (like a foreign key) in\nthe "child" entity.')]),e._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[e._v("WARNING")]),e._v(" "),a("p",[e._v("One aggregate should only reference external entities that are aggregate roots.\nFor example, if a "),a("em",[e._v("Customer")]),e._v(" has some "),a("em",[e._v("Address")]),e._v(", other aggregates (e.g.,\n"),a("em",[e._v("Order")]),e._v(") should not reference the "),a("em",[e._v("Address")]),e._v(" directly. Instead, they should get\nthat address through a "),a("em",[e._v("Customer")]),e._v(".")]),e._v(" "),a("p",[e._v("Aggregate Roots define the complete entity. We should not link some other\naggregate to a part of an aggregate.")]),e._v(" "),a("p",[e._v("However, it's OK to link to some other non-root entity by the FK.")])]),e._v(" "),a("p",[e._v("When thinking to associate two aggregates, it's worth to remember what defines\nan Aggregate Root:")]),e._v(" "),a("blockquote",[a("p",[e._v("We need to look at individual components and think if the removal of a given\ncomponent would result in removal of its contained components. If it would,\nthat's probably an Aggregate Root.")])]),e._v(" "),a("p",[e._v('If removal of our root should not result in the removal of linked aggregates,\npossibly we don\'t need to include these children as "Navigation Properties".\nInstead, maybe just an ID of that other entitiy is enough.')]),e._v(" "),a("p",[e._v("An example is an aggregate called "),a("em",[e._v("Appointment")]),e._v(". It would contain references to:")]),e._v(" "),a("ul",[a("li",[e._v("Patient")]),e._v(" "),a("li",[e._v("Doctor")])]),e._v(" "),a("p",[e._v("However, since removing an Appointment should not remove Patient and Doctor, it\nmakes sense to reference these just by ID, not by Navigation Properites.")]),e._v(" "),a("h2",{attrs:{id:"shared-kernel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shared-kernel"}},[e._v("#")]),e._v(" Shared Kernel")]),e._v(" "),a("p",[e._v("In DDD, a "),a("strong",[e._v("Shared Kernel")]),e._v(" is code that is used between different bounded\ncontext. It's basically a kind of project that .NET developers often call\n"),a("em",[e._v("Common")]),e._v(". The shared part should be as stable as possible. Changes in that code\nwill affect a lot of places.")]),e._v(" "),a("h2",{attrs:{id:"repositories"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#repositories"}},[e._v("#")]),e._v(" Repositories")]),e._v(" "),a("p",[e._v("Repository pattern is a well-known approach and it is also used outside of DDD.\nDDD-specific fact is that only the Aggregate Roots should have their\nrepositories. Other aggregates should be accessed via their aggregate roots.")]),e._v(" "),a("p",[e._v("A few tips:")]),e._v(" "),a("ul",[a("li",[e._v("there should be some common "),a("code",[e._v("IRepository<T>")]),e._v(" interface implementated by all the repositories")]),e._v(" "),a("li",[e._v("if some kind of repository (like "),a("code",[e._v("PatientsRepository")]),e._v(") has special needs, it's\nOK to add some special methods to just that repository (or rather its\ninterface "),a("code",[e._v("IPatientsRepository")]),e._v("). An example of such a method could be\n"),a("code",[e._v("GetPatientsOfDoctorWithId(Guid doctorId)")]),e._v(".")]),e._v(" "),a("li",[e._v("we could have separate repositories for querying and commanding, following CQRS.")])]),e._v(" "),a("h3",{attrs:{id:"specifications"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specifications"}},[e._v("#")]),e._v(" Specifications")]),e._v(" "),a("p",[e._v("The second point from the list above might turn some repositories into huge\nclasses. The solution for that is to turn these specific use-cases into\nso-called "),a("strong",[e._v("Specifications")]),e._v(". These are classes that provide predicates for\ndifferent use-cases. Then, our repositories would have a way to provide a\nspecification to it.")]),e._v(" "),a("div",{staticClass:"language-cs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cs"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("interface")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("IRepository"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("T"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token return-type class-name"}},[e._v("T")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("GetBySpec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Specification")]),e._v(" spec"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("It is similar to the Strategy pattern. It also provides separation of concerns\nsince the repository code can stay relatively clean and simple, while specific\nuse-cases will be handled by their own classes.")]),e._v(" "),a("p",[e._v("It will work well with Entity Framework or ORMs in general. Other data access\nmethods would requie Specifications that are aware of the persistance layer\nquery language, I believe.")]),e._v(" "),a("h2",{attrs:{id:"sources"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sources"}},[e._v("#")]),e._v(" Sources")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://app.pluralsight.com/library/courses/fundamentals-domain-driven-design",target:"_blank",rel:"noopener noreferrer"}},[e._v("Domain-Driven Design Fundamentals\n(Pluralsight)"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://www.codeproject.com/Articles/1020932/Domain-Driven-Design-Reflecting-Business-in-the-Do",target:"_blank",rel:"noopener noreferrer"}},[e._v("Code\nProject"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=n.exports}}]);