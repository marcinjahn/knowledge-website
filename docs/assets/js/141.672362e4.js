(window.webpackJsonp=window.webpackJsonp||[]).push([[141],{638:function(e,t,v){"use strict";v.r(t);var s=v(22),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"configuration"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#configuration"}},[e._v("#")]),e._v(" Configuration")]),e._v(" "),v("p",[e._v("Applications in pods might be configured in a few ways.")]),e._v(" "),v("h2",{attrs:{id:"configmaps"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#configmaps"}},[e._v("#")]),e._v(" ConfigMaps")]),e._v(" "),v("h3",{attrs:{id:"mounting-as-volumes"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mounting-as-volumes"}},[e._v("#")]),e._v(" Mounting as volumes")]),e._v(" "),v("p",[e._v("When mounting a ConfigMap/Secret as a volume, the files in the container are\nactually symbolic links. Next to them is a directory with the actual files. This\nwas done so that when configMap changes, and Kubernetes updates the files, the\nsymbolic links will be switched to point to new files only after all of them get\nupdated properly. This solves a potential issue of container seeing only half of\nthe files being updated, which could lead to improper configuration of the app.")]),e._v(" "),v("p",[e._v("When using "),v("code",[e._v("subPath")]),e._v(" while mounting configMap, the files do not get updated\ntogether with configMap updates.")]),e._v(" "),v("h3",{attrs:{id:"secrets"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#secrets"}},[e._v("#")]),e._v(" Secrets")]),e._v(" "),v("p",[e._v("Secrets are very similar to configMaps. Some differences:")]),e._v(" "),v("ul",[v("li",[e._v("Secrets are only distrubuted to the Nodes that run the Pods taht need the\ngiven Secret.")]),e._v(" "),v("li",[e._v("Secrets in the Nodes are always only in memory, never written to the disk.")])]),e._v(" "),v("p",[e._v("By default Secrets have "),v("code",[e._v("type")]),e._v(" set to "),v("code",[e._v("Opaque")]),e._v(". There are various types of\nsecrets used by various K8s components. Examples of secret types:")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("kubernetes.io/basic-auth")]),e._v(" - must container "),v("code",[e._v("username")]),e._v(" and "),v("code",[e._v("password")])]),e._v(" "),v("li",[v("code",[e._v("kubernetes.io/tls")]),e._v(" - must contain "),v("code",[e._v("tls.crt")]),e._v(" and "),v("code",[e._v("tls.key")])])]),e._v(" "),v("p",[e._v("Secrets objects store secrets under the "),v("code",[e._v("data")]),e._v(" key in base64 encoded format. In\norder to crete a secret, you can either provide the base64-encoded values under\n"),v("code",[e._v("data")]),e._v(" or provide raw values under the "),v("code",[e._v("stringData")]),e._v(" key. They will be\ntransformed to base64 and put under data by K8s. "),v("code",[e._v("stringData")]),e._v(" is only writable,\nnot readable.")]),e._v(" "),v("h3",{attrs:{id:"downward-api"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#downward-api"}},[e._v("#")]),e._v(" Downward API")]),e._v(" "),v("p",[e._v("It allows to expose pod and container metadata ("),v("code",[e._v("metadata")]),e._v(", "),v("code",[e._v("spec")]),e._v(" or "),v("code",[e._v("status")]),e._v("\nfields and resource constraints, like CPU, RAM) via environment variables or\nfiles (like ConfigMaps).")]),e._v(" "),v("p",[e._v("Supported metadata fields:")]),e._v(" "),v("table",[v("thead",[v("tr",[v("th",[e._v("Field")]),e._v(" "),v("th",[e._v("Description")]),e._v(" "),v("th",[e._v("Allowed in env")]),e._v(" "),v("th",[e._v("Allowed in volume")])])]),e._v(" "),v("tbody",[v("tr",[v("td",[e._v("metadata.name")]),e._v(" "),v("td",[e._v("The pod's name.")]),e._v(" "),v("td",[e._v("Yes")]),e._v(" "),v("td",[e._v("Yes")])]),e._v(" "),v("tr",[v("td",[e._v("metadata.namespace")]),e._v(" "),v("td",[e._v("The pod's namespace.")]),e._v(" "),v("td",[e._v("Yes")]),e._v(" "),v("td",[e._v("Yes")])]),e._v(" "),v("tr",[v("td",[e._v("metadata.uid")]),e._v(" "),v("td",[e._v("The pod's UID.")]),e._v(" "),v("td",[e._v("Yes")]),e._v(" "),v("td",[e._v("Yes")])]),e._v(" "),v("tr",[v("td",[e._v("metadata.labels")]),e._v(" "),v("td",[e._v('All the pod\'s labels, one label per line, formatted as key="value"')]),e._v(" "),v("td",[e._v("No")]),e._v(" "),v("td",[e._v("Yes")])]),e._v(" "),v("tr",[v("td",[e._v("metadata.labels['key']")]),e._v(" "),v("td",[e._v("The value of the specified label.")]),e._v(" "),v("td",[e._v("Yes")]),e._v(" "),v("td",[e._v("Yes")])]),e._v(" "),v("tr",[v("td",[e._v("metadata.annotations")]),e._v(" "),v("td",[e._v('All the pod\'s annotations, one per line, formatted as key="value".')]),e._v(" "),v("td",[e._v("No")]),e._v(" "),v("td",[e._v("Yes")])]),e._v(" "),v("tr",[v("td",[e._v("metadata.annotations['key']")]),e._v(" "),v("td",[e._v("The value of the specified annotation.")]),e._v(" "),v("td",[e._v("Yes")]),e._v(" "),v("td",[e._v("Yes")])]),e._v(" "),v("tr",[v("td",[e._v("spec.nodeName")]),e._v(" "),v("td",[e._v("The name of the worker node the pod runs on.")]),e._v(" "),v("td",[e._v("Yes")]),e._v(" "),v("td",[e._v("No")])]),e._v(" "),v("tr",[v("td",[e._v("spec.serviceAccountName")]),e._v(" "),v("td",[e._v("The name of the pod's service account.")]),e._v(" "),v("td",[e._v("Yes")]),e._v(" "),v("td",[e._v("No")])]),e._v(" "),v("tr",[v("td",[e._v("status.podIp")]),e._v(" "),v("td",[e._v("The pod's IP address.")]),e._v(" "),v("td",[e._v("Yes")]),e._v(" "),v("td",[e._v("No")])]),e._v(" "),v("tr",[v("td",[e._v("status.hostIP")]),e._v(" "),v("td",[e._v("The worker node's IP address.")]),e._v(" "),v("td",[e._v("Yes")]),e._v(" "),v("td",[e._v("No")])])])]),e._v(" "),v("p",[e._v("Supported resource cnstraints injection:")]),e._v(" "),v("table",[v("thead",[v("tr",[v("th",[e._v("Resource field")]),e._v(" "),v("th",[e._v("Description")]),e._v(" "),v("th",[e._v("Allowed in env")]),e._v(" "),v("th",[e._v("Allowed in vol")])])]),e._v(" "),v("tbody",[v("tr",[v("td",[e._v("requests.cpu")]),e._v(" "),v("td",[e._v("The container's CPU request.")]),e._v(" "),v("td",[e._v("Yes")]),e._v(" "),v("td",[e._v("Yes")])]),e._v(" "),v("tr",[v("td",[e._v("requests.memory")]),e._v(" "),v("td",[e._v("The container's memory request.")]),e._v(" "),v("td",[e._v("Yes")]),e._v(" "),v("td",[e._v("Yes")])]),e._v(" "),v("tr",[v("td",[e._v("requests.ephemeral-storage")]),e._v(" "),v("td",[e._v("The container's ephemeral storage request.")]),e._v(" "),v("td",[e._v("Yes")]),e._v(" "),v("td",[e._v("Yes")])]),e._v(" "),v("tr",[v("td",[e._v("limits.cpu")]),e._v(" "),v("td",[e._v("The container's CPU limit.")]),e._v(" "),v("td",[e._v("Yes")]),e._v(" "),v("td",[e._v("Yes")])]),e._v(" "),v("tr",[v("td",[e._v("limits.memory")]),e._v(" "),v("td",[e._v("The container's memory limit.")]),e._v(" "),v("td",[e._v("Yes")]),e._v(" "),v("td",[e._v("Yes")])]),e._v(" "),v("tr",[v("td",[e._v("limits.ephemeral-storage")]),e._v(" "),v("td",[e._v("The container's ephemeral storage limit.")]),e._v(" "),v("td",[e._v("Yes")]),e._v(" "),v("td",[e._v("Yes")])])])]),e._v(" "),v("h3",{attrs:{id:"projected-volumes"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#projected-volumes"}},[e._v("#")]),e._v(" Projected Volumes")]),e._v(" "),v("p",[e._v("When mounting Secrets, ConfigMaps, Downward API as volumes, they cannot be\nmounted in the same directory (unless using "),v("code",[e._v("subPath")]),e._v("). Projected Volumes allow\nto do that.")])])}),[],!1,null,null,null);t.default=a.exports}}]);