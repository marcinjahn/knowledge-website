(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{523:function(e,t,s){"use strict";s.r(t);var a=s(31),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"equality"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#equality"}},[e._v("#")]),e._v(" Equality")]),e._v(" "),s("h2",{attrs:{id:"good-practices"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#good-practices"}},[e._v("#")]),e._v(" Good Practices")]),e._v(" "),s("h3",{attrs:{id:"reference-types"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reference-types"}},[e._v("#")]),e._v(" Reference Types")]),e._v(" "),s("ul",[s("li",[e._v("Override "),s("code",[e._v("Object")]),e._v("'s virtual "),s("code",[e._v("Equals(object o)")]),e._v(" method (check for: "),s("code",[e._v("null")]),e._v(",\n"),s("code",[e._v("ReferenceEquals")]),e._v(", fields/properties). For inherited types, first call\n"),s("code",[e._v("base.Equals()")]),e._v(" and then check for added properties/fields")]),e._v(" "),s("li",[e._v("Implement "),s("code",[e._v("==")]),e._v(" and "),s("code",[e._v("!=")]),e._v(" - to enable "),s("code",[e._v("==")]),e._v(" and "),s("code",[e._v("!=")]),e._v(" (could use the "),s("code",[e._v("Object")]),e._v("'s\nstatic "),s("code",[e._v("Equals")]),e._v(", which will call the overridern "),s("code",[e._v("Equals")]),e._v(")")]),e._v(" "),s("li",[e._v("All of the above should give the same results")]),e._v(" "),s("li",[e._v("Implement "),s("code",[e._v("Object.GetHashCode()")])])]),e._v(" "),s("p",[e._v("Implementing "),s("code",[e._v("IEnumerable<T>")]),e._v(" is not recommended since it introduces inheritance\nproblems (unless the class is "),s("code",[e._v("sealed")]),e._v(") and does not give any real benefits\nhere.")]),e._v(" "),s("h3",{attrs:{id:"value-types"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#value-types"}},[e._v("#")]),e._v(" Value Types")]),e._v(" "),s("ul",[s("li",[e._v("Implement "),s("code",[e._v("IEquatable<T>")]),e._v(" - to avoid boxing and have type safety")]),e._v(" "),s("li",[e._v("Override "),s("code",[e._v("Object")]),e._v("'s virtual "),s("code",[e._v("Equals(object o)")]),e._v(" method - to avoid reflection\n(just call the "),s("code",[e._v("IEquatable<T>")]),e._v(" version)")]),e._v(" "),s("li",[e._v("Implement "),s("code",[e._v("==")]),e._v(" and "),s("code",[e._v("!=")]),e._v(" - to enable "),s("code",[e._v("==")]),e._v(" and "),s("code",[e._v("!=")]),e._v(" (just call the\n"),s("code",[e._v("IEquatable<T>")]),e._v(" version)")]),e._v(" "),s("li",[e._v("All of the above should give the same results")]),e._v(" "),s("li",[e._v("Implement "),s("code",[e._v("Object.GetHashCode()")])])]),e._v(" "),s("h2",{attrs:{id:"hash-codes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hash-codes"}},[e._v("#")]),e._v(" Hash Codes")]),e._v(" "),s("p",[e._v("Hash codes are used in HashSets and Dictionaries to be able to retrieve elements\nefficiently. If two objects are equal they should have the same hash codes (or\ndictionaries might not work)! Therefore "),s("code",[e._v("Equals")]),e._v(" and "),s("code",[e._v("GetHashCode")]),e._v(" should rely\non the same set of properties to get the result.")]),e._v(" "),s("p",[e._v("It's recommended to implement hashcodes using XOR operator ("),s("code",[e._v("^")]),e._v("):")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("public override int GetHashCode()\n{\n    return prop1.GetHashCode() ^ prop2.GetHashCode()\n}\n")])])]),s("h2",{attrs:{id:"object-s-virtual-equals-object-o-method"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-s-virtual-equals-object-o-method"}},[e._v("#")]),e._v(" "),s("code",[e._v("Object")]),e._v("'s virtual "),s("code",[e._v("Equals(object o)")]),e._v(" method")]),e._v(" "),s("h3",{attrs:{id:"classes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#classes"}},[e._v("#")]),e._v(" Classes")]),e._v(" "),s("p",[e._v("In classes it evaluates "),s("strong",[e._v("reference")]),e._v(" equality, unless overriden. "),s("code",[e._v("String")]),e._v(",\n"),s("code",[e._v("tuples")]),e._v(" and "),s("code",[e._v("delegate")]),e._v(" have it overriden.")]),e._v(" "),s("h3",{attrs:{id:"structs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#structs"}},[e._v("#")]),e._v(" Structs")]),e._v(" "),s("p",[e._v("In structs it compares values - all fields are compared (uses reflection). It's\nrecommended to override "),s("code",[e._v("Equals(object o)")]),e._v(" by ourselves, because reflection has\nvery bad performance.")]),e._v(" "),s("p",[e._v("It involves boxing in case of value types, which also is not a good thing. It's\na good practice to always override "),s("code",[e._v("GetHashCode")]),e._v(" when overriding "),s("code",[e._v("Equals")]),e._v(".")]),e._v(" "),s("h2",{attrs:{id:"object-s-static-equals-object-o1-object-o2-method"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-s-static-equals-object-o1-object-o2-method"}},[e._v("#")]),e._v(" "),s("code",[e._v("Object")]),e._v("'s static "),s("code",[e._v("Equals(object o1, object o2)")]),e._v(" method")]),e._v(" "),s("p",[e._v("This method makes it safe to compare 2 objects if one of them is "),s("code",[e._v("NULL")]),e._v(". If they\nare not both "),s("code",[e._v("NULL")]),e._v(", the virtual "),s("code",[e._v("Equals")]),e._v(" of "),s("code",[e._v("o1")]),e._v(" is used (as described above).\nSo this method gives the same result as virtual one (only it protects from case\nwhere "),s("code",[e._v("o1")]),e._v(" is "),s("code",[e._v("NULL")]),e._v(").")]),e._v(" "),s("p",[e._v("It cannot be overriden (because it's static)")]),e._v(" "),s("h2",{attrs:{id:"object-s-referenceequals-object-o-method"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-s-referenceequals-object-o-method"}},[e._v("#")]),e._v(" "),s("code",[e._v("Object")]),e._v("'s "),s("code",[e._v("ReferenceEquals(Object o)")]),e._v(" method")]),e._v(" "),s("p",[e._v("It checks only reference, it cannot be overriden (becasue it's static). Useful\nin the case where some type overrides the virtual "),s("code",[e._v("Equals")]),e._v(", but also wants to\ncheck for reference equality.")]),e._v(" "),s("h2",{attrs:{id:"iequatable-t"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#iequatable-t"}},[e._v("#")]),e._v(" "),s("code",[e._v("IEquatable<T>")])]),e._v(" "),s("p",[e._v("It has the following method: "),s("code",[e._v("Equals(T other)")]),e._v(" - it is strongly typed, which is\ngood for value types (no boxing). All numeric primitive types implement it\n("),s("code",[e._v("Int")]),e._v(", "),s("code",[e._v("byte")]),e._v(", ...), other primitives not always. Some reference types\nimplement it (i.e. "),s("code",[e._v("String")]),e._v(").")]),e._v(" "),s("p",[e._v("If some type implements it, we should make sure that both strong typed "),s("code",[e._v("Equals")]),e._v("\nand the one from "),s("code",[e._v("Object")]),e._v(" return the same results.")]),e._v(" "),s("p",[e._v("It is not good for reference types:")]),e._v(" "),s("ul",[s("li",[e._v("there is no boxing, so no improvement in this area")]),e._v(" "),s("li",[e._v("doesn't play nicely with inheritance")])]),e._v(" "),s("h2",{attrs:{id:"operator"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#operator"}},[e._v("#")]),e._v(" "),s("code",[e._v("==")]),e._v(" operator")]),e._v(" "),s("p",[e._v("It's a feature of C#, not .NET. If overriding "),s("code",[e._v("Object")]),e._v("'s "),s("code",[e._v("Equals")]),e._v(", "),s("code",[e._v("==")]),e._v(" also\nshould be overriden. "),s("code",[e._v("==")]),e._v(" does not use "),s("code",[e._v("Equals")]),e._v(" - it uses "),s("code",[e._v("eqc")]),e._v(" IL procedure\ndirectly, which (?) uses hardware (unless overriden).")]),e._v(" "),s("p",[s("code",[e._v("Tuple")]),e._v(" does not override "),s("code",[e._v("==")]),e._v(", but overrides "),s("code",[e._v("Object.Equals()")]),e._v(" - because of\nthat operator only checks reference equality and can return different result\nthan "),s("code",[e._v("Object.Equals()")]),e._v(" - bad practice!")]),e._v(" "),s("p",[e._v("Implementing "),s("code",[e._v("==")]),e._v(" requires implementing also "),s("code",[e._v("!=")]),e._v(" (by compiler).")]),e._v(" "),s("h3",{attrs:{id:"inheritance"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#inheritance"}},[e._v("#")]),e._v(" Inheritance")]),e._v(" "),s("p",[s("code",[e._v("==")]),e._v(" does not work well with inheritance - if we cast "),s("code",[e._v("MyClass")]),e._v(" to "),s("code",[e._v("Object")]),e._v(" and\ncompare, it will use "),s("code",[e._v("Object")]),e._v("'s "),s("code",[e._v("==")]),e._v(" implementation (reference equality).\n"),s("code",[e._v("Equals")]),e._v(" methods don't have this issue.")]),e._v(" "),s("h3",{attrs:{id:"generics"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#generics"}},[e._v("#")]),e._v(" Generics")]),e._v(" "),s("p",[e._v("With generics, "),s("code",[e._v("==")]),e._v(" ALWAYS compares references (even if "),s("code",[e._v("T")]),e._v(" implements the\noperator). "),s("code",[e._v("Object.Equals()")]),e._v(" should be used here!")]),e._v(" "),s("h3",{attrs:{id:"struct"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#struct"}},[e._v("#")]),e._v(" Struct")]),e._v(" "),s("p",[e._v("For value types it has to be overloaded before using it.")]),e._v(" "),s("h3",{attrs:{id:"classes-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#classes-2"}},[e._v("#")]),e._v(" Classes")]),e._v(" "),s("p",[e._v("For classes it compares the references (memory addresses), unless overriden.")]),e._v(" "),s("h3",{attrs:{id:"overloading"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#overloading"}},[e._v("#")]),e._v(" Overloading")]),e._v(" "),s("div",{staticClass:"language-csharp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-csharp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("static")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("bool")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("operator")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("==")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MyClass")]),e._v(" left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MyClass")]),e._v(" right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Equality logic")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("static")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("bool")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("operator")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("!=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MyClass")]),e._v(" left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MyClass")]),e._v(" right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Inequality logic")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),s("p",[e._v("The logic should be the same as in "),s("code",[e._v("Object.Equals()")]),e._v("!")]),e._v(" "),s("h2",{attrs:{id:"iequalitycomparer-t"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#iequalitycomparer-t"}},[e._v("#")]),e._v(" "),s("code",[e._v("IEqualityComparer<T>")])]),e._v(" "),s("p",[e._v("Requires "),s("code",[e._v("Equals")]),e._v(" and "),s("code",[e._v("GetHashCode")]),e._v(" to be implemented. It's adviced to inherit\nfrom "),s("code",[e._v("EqualityComparer<T>")]),e._v(" base class (similar as with "),s("code",[e._v("Comparer<T>")]),e._v(").")]),e._v(" "),s("p",[e._v("EqualityComparer is adviced to be a singleton.")]),e._v(" "),s("p",[e._v("It's problematic to deal with derived types - as exmplained in my notes on\ncomparers.")]),e._v(" "),s("p",[s("code",[e._v("EqualityComparer<T>.Default")]),e._v(" - every type can use the default comparer, which\nuses the "),s("code",[e._v("T")]),e._v("'s equality implementation.")]),e._v(" "),s("p",[s("code",[e._v("StringComparer")]),e._v(" is a static class that has 6 variosu comparers for strings\n(implements "),s("code",[e._v("IComparer")]),e._v(" and "),s("code",[e._v("IEqualityComparer")]),e._v(").")]),e._v(" "),s("h2",{attrs:{id:"istructuralequatable"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#istructuralequatable"}},[e._v("#")]),e._v(" "),s("code",[e._v("IStructuralEquatable")])]),e._v(" "),s("p",[e._v("Collections are structurally equal if:")]),e._v(" "),s("ul",[s("li",[e._v("they contain same elements")]),e._v(" "),s("li",[e._v("elements are in the same order")])]),e._v(" "),s("p",[e._v("Arrays and tuples implement it explicitly - in order to use it, we need to cast\nan array to "),s("code",[e._v("IStructuralEquatable")]),e._v(" and use "),s("code",[e._v("Equals")]),e._v(" It's not generic.")]),e._v(" "),s("h2",{attrs:{id:"other-notes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#other-notes"}},[e._v("#")]),e._v(" Other Notes")]),e._v(" "),s("p",[e._v("In .NET "),s("code",[e._v("NULL")]),e._v(" always equals "),s("code",[e._v("NULL")]),e._v(", i.e.: "),s("code",[e._v("Object.Equals(null, null)")]),e._v(" returns\n"),s("code",[e._v("TRUE")]),e._v(".")])])}),[],!1,null,null,null);t.default=o.exports}}]);